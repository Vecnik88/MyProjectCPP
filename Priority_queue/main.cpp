// created by Vecnik88
/*
                        Параллельная обработка

    По данным n процессорам и m задач определите, для каждой из задач,
каким процессором она будет обработана.

    Вход. Число процессоров n и последовательность чисел
t0, . . . , tm−1, где ti — время, необходимое на обработку i-й
задачи.

    Выход. Для каждой задачи определите, какой процессор
и в какое время начнёт её обрабатывать, предполагая, что
каждая задача поступает на обработку первому освободив-
шемуся процессору.

    В данной задаче ваша цель — реализовать симуляцию параллель-
ной обработки списка задач. Такие обработчики (диспетчеры) есть во
всех операционных системах.

    У вас имеется n процессоров и последовательность из m задач. Для
каждой задачи дано время, необходимое на её обработку. Очеред-
ная работа поступает к первому доступному процессору (то есть если
доступных процессоров несколько, то доступный процессор с мини-
мальным номером получает эту работу).

    Формат входа. Первая строка входа содержит числа n и m. Вторая
содержит числа t0, . . . , tm−1, где ti — время, необходимое на об-
работку i-й задачи. Считаем, что и процессоры, и задачи нуме-
руются с нуля.

    Формат входа. Выход должен содержать ровно m строк: i-я (считая
с нуля) строка должна содержать номер процесса, который по-
лучит i-ю задачу на обработку, и время, когда это произойдёт.

Ограничения. 1 ≤ n ≤ 105; 1 ≤ m ≤ 105; 0 ≤ ti ≤ 109.
21
Пример.
Вход:
2 5
1 2 3 4 5
Выход:
0 0
1 0
0 1
1 2
0 4
Пример.
Вход:
4 20
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
Выход:
0 0
1 0
2 0
3 0
0 1
1 1
2 1
3 1
0 2
1 2
2 2
3 2
0 3
1 3
2 3
3 3
0 4
1 4
2 4
3 4
*/

#include <iostream>
#include <queue>

using Range = std::pair<int, long>;                             // first - id процесса
                                                                // second - время окончания процесса
struct compare
{
   bool operator()(const Range& one, const Range& two)          // <---. предикат
   {
       if(one.second == two.second)                             // <---. если равно время, освобождаем процесс с наим. ид
           return one.first > two.first;

       return one.second > two.second;
   }
};

int main()
{
    std::priority_queue<Range, std::vector<Range>, compare> timeArray;
    int valueProccess = 0;                                      // <---. кол-во процессов
    int valueAsk = 0;                                           // <---. кол-во задач

    std::cin >> valueProccess >> valueAsk;
    unsigned arrayAskTime[valueAsk];                                 // <---. массив для времени i-той задачи

    for(int i = 0; i < valueAsk; ++i)
    {
        std::cin >> arrayAskTime[i];
    }
    for(int i = 0; i < valueAsk; ++i)
    {
        if(i < valueProccess)
        {
            timeArray.push({i, arrayAskTime[i]});
            std::cout << i << " " << 0 << std::endl;
            continue;
        }

    if(!timeArray.empty())
    {
        std::cout << timeArray.top().first << " " << timeArray.top().second << std::endl;
        timeArray.push({timeArray.top().first, timeArray.top().second + arrayAskTime[i]});
        timeArray.pop();
    }
    else
        break;
    }

    return 0;
}
